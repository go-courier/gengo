package gengo

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/scanner"
	"go/token"
	"io"
	"os"
	"path"
	"sort"
	"strings"

	"github.com/octohelm/gengo/pkg/gengo/internal"
	"github.com/octohelm/gengo/pkg/gengo/snippet"
	"github.com/octohelm/gengo/pkg/namer"
	gformat "mvdan.cc/gofumpt/format"
)

func newGenfile() *genfile {
	return &genfile{
		imports: namer.NewDefaultImportTracker(),
		body:    bytes.NewBuffer(nil),
	}
}

type genfile struct {
	generator Generator
	body      *bytes.Buffer
	imports   namer.ImportTracker
	SnippetWriter
}

func (c *genfile) IsZero() bool {
	return c.body == nil || c.body.Len() == 0
}

func (ff *genfile) InitWith(c Context) error {
	pkg := c.Package("")
	pkgPath := pkg.Pkg().Path()

	ff.SnippetWriter = NewSnippetWriter(ff.body, map[string]namer.Namer{
		"raw": namer.NewRawNamer(pkgPath, ff.imports),
	})

	return nil
}

func (ff *genfile) Filename(args *GeneratorArgs) string {
	return fmt.Sprintf("%s.%s.go", args.OutputFileBaseName, ff.generator.Name())
}

func (ff *genfile) WriteToFile(c Context, args *GeneratorArgs) error {
	// nothing generated
	if ff.body.Len() == 0 {
		return nil
	}

	pkgName := c.Package("").Pkg().Name()

	src := bytes.NewBuffer(nil)

	_, _ = fmt.Fprintf(src, `/*
Package %s GENERATED BY gengo:%s 
DON'T EDIT THIS FILE
*/
package %s
`, pkgName, ff.generator.Name(), pkgName)

	writeImports(src, ff.imports.Imports())

	if _, err := io.Copy(src, ff.body); err != nil {
		return err
	}

	filename := path.Join(c.Package("").SourceDir(), ff.Filename(args))

	data := src.Bytes()

	lines := bytes.Split(data, []byte("\n"))

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, filename, data, parser.ParseComments|parser.SkipObjectResolution|parser.AllErrors)
	if err != nil {
		var sl scanner.ErrorList
		if errors.As(err, &sl) {
			for i := range sl {
				if i > 0 {
					// only should first error
					break
				}

				l := sl[i].Pos.Line
				fmt.Println(sl[i].Pos)
				for i := l - 10; i < l; i++ {
					if i > 0 {
						fmt.Printf("%d\t%s\n", i+1, string(lines[i]))
					}
				}

				col := sl[i].Pos.Column - 1
				if col < 0 {
					col = 0
				}
				fmt.Printf("\t%sâ†‘\n", strings.Repeat(" ", col))
				fmt.Println(sl[i].Msg)
				fmt.Println()
			}
		}
		return err
	}

	m := c.Package("").Module()

	ast.SortImports(fset, file)

	gformat.File(fset, file, gformat.Options{
		LangVersion: "go" + m.GoVersion,
		ModulePath:  m.Path,
		ExtraRules:  false,
	})

	f, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0o666)
	if err != nil {
		if os.IsNotExist(err) {
			f, err = os.Create(filename)
			if err != nil {
				return err
			}
		}
		return err
	}

	defer f.Close()

	return format.Node(f, fset, file)
}

func merge(tagsList ...map[string][]string) map[string][]string {
	mergedTags := make(map[string][]string)

	for _, tags := range tagsList {
		for k, values := range tags {
			mergedTags[k] = values
		}
	}

	return mergedTags
}

func writeImports(w io.Writer, pathToName map[string]string) {
	importPaths := make([]string, 0)
	for p := range pathToName {
		importPaths = append(importPaths, p)
	}
	sort.Sort(sort.StringSlice(importPaths))

	if len(importPaths) > 0 {
		_, _ = fmt.Fprintf(w, `
import (
`)

		for _, p := range importPaths {
			_, _ = fmt.Fprintf(w, `	%s "%s"
`, pathToName[p], p)
		}

		_, _ = fmt.Fprintf(w, `)
`)
	}
}

type SnippetWriter interface {
	Render(snippet snippet.Snippet)
}

func NewSnippetWriter(w io.Writer, ns namer.NameSystems) SnippetWriter {
	return &snippetWriter{
		Writer: w,
		ns:     ns,
	}
}

type snippetWriter struct {
	ns namer.NameSystems

	io.Writer
}

func (sw *snippetWriter) Dumper() *internal.Dumper {
	if rawNamer, ok := sw.ns["raw"]; ok {
		return internal.NewDumper(rawNamer)
	}
	return nil
}

func (sw *snippetWriter) Render(snippet snippet.Snippet) {
	if snippet == nil {
		return
	}

	if !snippet.IsNil() {
		for code := range snippet.Frag(internal.DumperContext.Inject(context.Background(), sw.Dumper())) {
			_, _ = io.WriteString(sw.Writer, code)
		}
	}
}
