package gengo

import (
	"bytes"
	"fmt"
	"go/format"
	"go/parser"
	"go/scanner"
	"go/token"
	"io"
	"os"
	"path"
	"sort"
	"strings"

	"github.com/go-courier/gengo/pkg/namer"
)

type genfiles map[string]*genfile

func (gfs genfiles) Init(c *Context, g Generator, postInits ...GeneratorPostInit) (Generator, error) {
	gf, ok := gfs[g.Name()]

	if !ok {
		gf = newGenfile(g.New())

		// register first to avoid loop
		gfs[g.Name()] = gf

		if err := gf.InitWith(c, g, gfs, postInits...); err != nil {
			return nil, err
		}
	}

	return gf.generator, nil
}

func newGenfile(g Generator) *genfile {
	return &genfile{
		generator: g,
		src:       bytes.NewBuffer(nil),
		body:      bytes.NewBuffer(nil),
		imports:   namer.NewDefaultImportTracker(),
	}
}

type genfile struct {
	generator Generator
	src       *bytes.Buffer
	body      *bytes.Buffer
	imports   namer.ImportTracker
	sw        SnippetWriter
}

func (ff *genfile) InitWith(c *Context, g Generator, gfs GeneratorCreator, postInits ...GeneratorPostInit) error {
	name := c.Package.Pkg().Name()
	pkgPath := c.Package.Pkg().Path()

	if _, err := fmt.Fprintf(ff.src, `package %s
`, name); err != nil {
		return err
	}

	ff.sw = NewSnippetWriter(ff.body, map[string]namer.Namer{
		"raw": namer.NewRawNamer(pkgPath, ff.imports),
	})

	g2, err := g.Init(c, gfs)
	if err != nil {
		return err
	}

	ff.generator = g2

	for i := range postInits {
		if postInit := postInits[i]; postInit != nil {
			if err := postInit(ff.generator, ff.sw); err != nil {
				return err
			}
		}
	}

	return nil
}

func (ff *genfile) WriteToFile(c *Context) error {
	// nothing generated
	if ff.body.Len() == 0 {
		return nil
	}

	writeImports(ff.src, ff.imports.Imports())

	if _, err := io.Copy(ff.src, ff.body); err != nil {
		return err
	}

	filename := path.Join(c.Package.SourceDir(), fmt.Sprintf("%s.%s.go", c.Args.OutputFileBaseName, ff.generator.Name()))
	data := ff.src.Bytes()

	lines := bytes.Split(data, []byte("\n"))

	fset := token.NewFileSet()
	astFile, err := parser.ParseFile(fset, filename, data, parser.AllErrors)
	if err != nil {
		if sl, ok := err.(scanner.ErrorList); ok {
			for i := range sl {
				l := sl[i].Pos.Line

				fmt.Println(sl[i].Pos)

				for i := l - 3; i < l; i++ {
					if i > 0 {
						fmt.Printf("%d\t%s\n", i+1, string(lines[i]))
					}
				}

				col := sl[i].Pos.Column - 1
				if col < 0 {
					col = 0
				}
				fmt.Printf("\t%sâ†‘\n", strings.Repeat(" ", col))
				fmt.Println(sl[i].Msg)
			}
		}
		return err
	}

	formattedSrc := bytes.NewBuffer(nil)

	if err := format.Node(formattedSrc, fset, astFile); err != nil {
		return err
	}

	f, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0666)
	if err != nil {
		if os.IsNotExist(err) {
			f, err = os.Create(filename)
			if err != nil {
				return err
			}
		}
		return err
	}

	defer f.Close()

	_, _ = fmt.Fprintf(f, `/*
Package %s GENERATED BY gengo:%s 
DON'T EDIT THIS FILE
*/
`, c.Package.Pkg().Name(), ff.generator.Name())

	_, err = io.Copy(f, formattedSrc)
	return err
}

func merge(tagsList ...map[string][]string) map[string][]string {
	mergedTags := make(map[string][]string, 0)

	for _, tags := range tagsList {
		for k, values := range tags {
			mergedTags[k] = values
		}
	}

	return mergedTags
}

func writeImports(w io.Writer, pathToName map[string]string) {
	importPaths := make([]string, 0)
	for p := range pathToName {
		importPaths = append(importPaths, p)
	}
	sort.Sort(sort.StringSlice(importPaths))

	if len(importPaths) > 0 {
		_, _ = fmt.Fprintf(w, `
import (
`)

		for _, p := range importPaths {
			_, _ = fmt.Fprintf(w, `	%s "%s"
`, pathToName[p], p)
		}

		_, _ = fmt.Fprintf(w, `)
`)
	}
}
